// 性质：
// 1、节点是红色或黑色
// 2、根节点是黑色
// 3、每个叶子节点都是黑色的空节点(NIL节点)
// 4、每个红色节点的两个子节点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色节点)
// 5、从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点

// 关键特性：从根到叶子的最长可能路径，不会超过最短可能路径的两倍长

// 让红黑树保持平衡的手段：换色、左旋、右旋
// 左旋：逆时针旋转红黑树的两个节点，使父节点被自己右子节点取代，自身成为原位置的左节点
//     x                   y
//  a     y     =>      x    c
//      b   c         a   b
// 右旋：顺时针旋转红黑树的两个节点，使父节点被自己左子节点取代，自身成为原位置的右节点
//      x                   y
//   y     a     =>      b     x
// b   c                     c   a

//      G
//   p      U
// N

// method:insert
// 情况1：N位于树的根上，那么直接将红色变换成黑色即可
// 情况2：N的父节点P是黑色，只需要把N的左右节点设置为NIL
// 情况3：P是红色，U也是红色，G是黑色，N是红色，需要转化为P黑U黑G红，但G的父节点也有可能是红色，这种情况下需要递归，若递归到了根节点，就需要进行旋转
//       G黑                 G红                G黑
//   P红     U红    =>    P黑    U黑    =>    P黑    U黑
// N红                  N红                N红
// 情况4：P红U黑G黑，N是左儿子 -> P转黑 G转红 右旋转
//       G黑                  P黑
//   p红     U黑    =>    N红      G红
// N红  B黑                     B黑   U黑
// 情况5：P红U黑G黑，N是右子节点，需要以P为根先进行左旋转，将P作为新插入的红节点考虑，以G为根，进行右旋转
//      G黑                 G黑                 N黑
//   P红    U黑    =>    N红    U黑    =>    P红    G红
// B黑  N红            P红                B黑         U黑
//                   B黑



















